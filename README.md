# Письменное задание для отбора на кафедру КИС

Автор: Сидоров Владислав Олегович\
Задача: Задача №2 / Алгоритмы

## Сборка
Соберите проект CMake
```shell
mkdir build
cd build
cmake -DCMAKE_BUILD_TYPE=Release ..
```

Соберите проект
```shell
make -j<num_cores + 1>
```

Исполняемый файл `kis_exam` теперь можно найти в папке bin
```shell
cd ../bin
./kis_exam
```

## Запуск программы
Исполняемый файл - `bin/kis_exam`\
Взаимодействие с программой происходит посредством вызова команд с параметрами

Таблица команд

| Команда | Параметры             | Описание                                         |
|---------|-----------------------|--------------------------------------------------|
| text    | строка (с пробелами)  | Добавить текст к словарю                         |
| request | строка (без пробелов) | Запросить подсказку "с чистого"                  |
| append  | строка (без пробелов) | Дописать символы к предыдущему запросу подсказки |
| help    | -                     | Вывести подсказку по командам                    |
| exit    | -                     | Завершить выполнение программы                   |


## Краткое описание реализации проекта
За основу решения взята структура данных «Бор»\
В вершинах бора хранится информация не только о том, сколько слов закончилось в этой вершине, но и самое популярное слово из соответствующего поддерева\
Таким образом, запрос подсказки является просто спуском по бору. Так же поддерживается запоминание последней позиции в боре при добавлении символов в запрос, т.е. при такой команде спуск в боре начинается не с корня, а с последней посещенной вершины\
Все операции выполняются за O(|s|) (то есть за длину входных данных)

## Подробное описание реализации проекта
- **Команда `text`**\
    Предварительно разбивает текст на слова по пробелам. Далее обрабатывает каждое слово отдельно. Добавляет слово в бор стандартным методом (пытается спуститься по очередному символу, если перехода нет, то создает новую вершину). После добавления проходит в обратном порядке по всем посещенным вершинам и обновляет информацию о самом популярном слове в поддереве. Очевидно, что самое популярное слово могло поменяться только для тех вершинах в боре, по которым прошли при добавлении слова, так то после этой команды бор всегда будет в актуальном состоянии\
    После добавления всех слов пытается обновить позицию для текущего запроса (см. поведение при отсутствии префикса)
- **Команда `request`**\
    Полностью обнуляет информацию о предыдущем запросе. Спускается по бору по символам в строке. Для ответа на запрос просто берет из вершины заранее готовую информацию о самом популярном слове в поддереве. Сохраняет позицию в боре для последующих дописываний
- **Команда `append`**\
    Полностью аналогично команде `request`, но теперь информация о предыдущем запросе не обнуляется, а спуск в боре начинается с сохраненной позиции
- **Поведение при отсутствии префикса**\
    Бывают ситуации, что по запросу просто не существует строк с требуемым префиксом в данных. Однако, после очередного добавления текста запрос может перестать быть пустым.\
    В данном случае программа не ломается, а запоминает части запроса, которые привели к выходу за границы бора, чтобы в дальнейшем при добавлении слов в бор иметь возможность "наверстать упущенное"\
    Более конкретно, в ситуации, когда выходим за границу бора, останавливаем спуск и сохраняем не только текущую позицию в боре, но и остаток строки, который не смогли обработать. Далее, после команды `text` заново запускаем спуск по бору по оставшейся части строки, чтобы актуализировать позицию
- **Структура проекта**\
    Проект разбит на четкие понятные классы, используются основные принципы ООП (без фанатизма для задачи на вечер)


